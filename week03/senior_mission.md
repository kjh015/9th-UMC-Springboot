# 시니어 미션

- [ ]  Soft Delete가 무엇인지 찾아보시고 soft delete에는 어떠한 HTTP Method가 들어가면 좋을지 적어주세요
    - 내용들을 간단하게 정리하여 주세요
        
        # Soft Delete란?
        
        데이터베이스에서 데이터를 삭제하지 않고, 사용자 입장에서는 데이터에 접근할 수 없게 하는 방식
        
        ## 사용이유 및 장점
        
        - 데이터가 유지되어야 하는 속성의 테이블인 경우 데이터를 남기기 위해
        - 데이터를 다시 복구해야하는 상황이 발생할 수 있기 때문에
        - update 쿼리가 delete 쿼리보다 ms단위로 조금 더 빠름
        
        ## 단점
        
        - 데이터를 저장하는 DB의 용량이 커짐
        - 테이블에 Soft Delete 용 칼럼이 하나 추가됨
        - 매번 삭제여부를 고려해 쿼리나 로직을 작성해야하는 불편함이있음
        
        ### Soft Delete에는 HTTP 메소드 중 PATCH를 사용하는 것이 좋다.
        
        PATCH는 리소스의 일부만  수정할 때 사용하는 메소드다. Soft Delete는 DB의 일부 필드만 변경하는 작업이므로 PATCH가 어울린다.
        

- [ ]  컨트롤 URI에 대해 조사해주시고 어떠할 때 사용이 가능한 지 예시를 들어 설명해주세요.
    - 내용들을 간단하게 정리하여 주세요
        
        # 컨트롤 URI란?
        
        RESTful API에서 **리소스를 조작**하거나 **특정 작업을 수행**하는 **Endpoint**
        
        보통 CRUD와 직접적인 연관이 없는 **비즈니스 로직 중심의 동작**을 수행할 때 사용
        
        일반적인 URI로는 비즈니스 로직을 표현하기 어려울 때 컨트롤 URI를 사용
        
        - 일반적인 URI: 특정 리소스를 가리키는 주소 역할
        - 컨트롤 URI: 동사처럼 특정 기능을 실행하는 역할
        
        # 컨트롤 URI를 언제 사용해야할까?
        
        - **CRUD API만으로 표현하기 어려운 비즈니스 로직이 필요할 때**
        - **리소스의 상태 변경이 아닌, 동작(행위) 자체를 표현할 때**
        - **비동기 처리, 트랜잭션 등이 포함된 API를 만들 때**
        
        ## 컨트롤 URI 예시
        
        ### 미션 성공처리
        
        - `POST /users/{userId}/missions/{missionId}/complete`
        
        ### 결제 승인
        
        - `POST /payments/{paymentId}/approve`
        
        ### 게시글 좋아요 누르기/취소
        
        - `POST /articles/{articleId}/like`
        - `DELETE /articles/{articleId}/like`

- [ ]  https://learn.microsoft.com/ko-kr/azure/architecture/best-practices/api-design - 문서를 읽고 주요 내용을 간단히 정리해주세요.
    - 내용들을 간단하게 정리하여 주세요
        
        # **RESTful 웹 API 디자인에 대한 모범 사례**
        
        **REST API는 다음 원칙에 부합해야 한다.**
        
        - **플랫폼 독립성**: 클라이언트는 내부 구현에 관계없이 웹 API를 호출할 수 있어야 한다. HTTP를 표준 프로토콜로 사용하고 명확한 설명서를 제공하며 JSON 또는 XML로 데이터를 교환해야한다.
        - **느슨한 결합**: 클라이언트와 서버는 서로 내부 구현을 알 필요가 없다. 클라이언트와 서버가 데이터를 교환할 수 있는 메커니즘이 있어야한다.
        
        본 문서에서는 RESTful 웹 API를 설계하기 위한 모범 사례를 설명한다.
        
        ---
        
        ## RESTful 웹 API 디자인 개념
        
        - **URI**
            - REST API는 클라이언트가 액세스할 수 있는 리소스(모든 종류의 개체, 데이터, 서비스)를 중심으로 설계되었다. 고유하게 식별되는 URI로 각 리소스를 표시한다.
        - **리소스 표현**
            - URI로 식별되는 리소스를 XML 또는 JSON과 같은 특정 형식으로 HTTP 프로톨클 통해 인코딩 및 전송하는 방법을 정의한다.
            - 클라이언트가 URI로 리소스를 검색하면 API는 데이터의 리소스 표현을 JSON/XML 형식으로 반환한다.
        - **균일한 인터페이스**
            - REST API가 클라이언트와 서버 간의 느슨한 결합을 달성하는 방법이다. HTTP 메소드를 사용하여 균일한 인터페이스를 유지한다.
        - **상태 비지정 요청 모델**
            - HTTP 요청은 독립적이며 어떤 순서로든 발생할 수 있다. 요청 간에 일시적인 상태 정보를 유지하는 것은 불가능하다(데이터 캐싱 불가).
            - 정보가 저장되는 유일한 위치는 리소스 자체에 있으며, 각 요청은 원자성 작업이어야 한다.
            - 클라이언트와 서버 간에 유지되는 연결이 없으므로 확장성이 높아진다.
            - 리소스는 오로지 URI에만 위치하며, 클라이언트와 서버는 각 요청에 대한 데이터를 저장하지 않는다. 즉, 클라이언트와 서버는 이전의 요청을 알 수 없다.
        - **하이퍼미디어 링크**
            - REST API는 각 리소스 표현에 포함된 하이퍼미디어 링크에 의해 구동될 수 있다.
            - 즉, 리소스에 하이퍼링크가 포함될 수 있다. 다음에 무엇을 할 수 있는지를 API에 포함시킬 수 있다.
            
        
        ---
        
        ## RESTful 웹 API 리소스 URI 정의
        
        리소스 URI는 명사를 기반으로 한다. 동사를 사용하여 작업을 나타내지 않는다.
        
        ### 리소스 URI 명명 규칙
        
        - 리소스 이름에 명사 사용
        - 복수 명사로 컬렉션 URI의 이름 지정
        - 다양한 유형의 리소스 간의 관계와 연결을 노출하는 방법을 고려 ex) 응답 메시지에 하이퍼링크 포함
        - 관계를 단순하고 유연하게 유지: URI는 단순하게
        - 적은 수의 리소스를 사용하지 않는다: 모든 웹 요청은 웹 서버에 부하를 부과한다. 한번의 요청에 가능한 많은 리소스를 포함하여 요청 횟수를 줄여야한다.
        - 데이터베이스 내부 구조를 미러링하는 API를 만들지 않는다: DB 테이블 내용을 리소스에 노출할 필요는 없다. DB와 API 사이에 매핑 계층 도입하여 데이터 누출을 방지하는 방법도 권장
        
        ### HTTP 요청 메서드
        
        **GET** 요청: 리소스를 **검색**
        
        - 반환하는 HTTP 상태코드: 200(OK), 204(내용 없음), 404(찾을 수 없음)
        
        **POST** 요청: 리소스를 **생성**
        
        - 반환하는 HTTP 상태코드: 200(OK), 201(만들어짐), 204(내용 없음), 400(잘못된 요청), 405(메서드 허용 안 됨)
        
        **PUT** 요청: **기존 리소스 업데이트**, 기존 리소스가 없으면 **새 리소스 생성**
        
        - 반환하는 HTTP 상태코드: 200(OK), 201(만들어짐), 204(내용 없음), 409(충돌)
        
        **PATCH** 요청: 기존 리소스에 대한 **부분 업데이트**
        
        - 반환하는 HTTP 상태코드: 200(OK), 400(잘못된 요청), 409(충돌), 415(지원되지 않는 미디어 형식)
        
        **DELETE** 요청: 리소스를 **제거**
        
        - 반환하는 HTTP 상태코드: 204(콘텐츠 없음), 404(찾을 수 없음)
        
        ### 리소스 MIME 형식
        
        리소스 표현은 URI로 식별되는 리소스를 XML 또는 JSON과 같은 특정 형식으로 HTTP 프로토콜을 통해 인코딩 및 전송하는 방법이다.
        
        특정 리소스를 검색하려는 클라이언트는 API에 대한 요청에서 URI를 사용해야 한다. API는 URI로 표시된 데이터의 리소스 표현을 반환하여 응답한다.
        
        HTTP 프로토콜에서 리소스 표현 형식은 MIME 형식이라고도 하는 미디어 형식을 사용하여 지정된다. 이진 데이터가 아닌 경우 대부분의 웹 API는 JSON(미디어 형식 = `application/json`) 및 XML(미디어 형식 = `application/xml`)을 지원한다.
        
        요청 또는 응답 Header의 Content-Type은 리소스 표현 형식을 지정한다.
        
        - Ex) `Content-Type: application/json; charset=utf-8`
        
        ---
        
        ## 비동기 메서드 구현
        
        경우에 따라 HTTP Method는 완료하는데 시간이 걸릴 수 있다. 이 대기 시간이 너무 오래 걸릴 경우, 메서드를 비동기식으로 만드는 것이 좋다.
        
        비동기 메서드는 상태 코드 202(수락됨)를 반환하여 요청이 허용되었지만, 완료되진 않았다는 것을 나타내야 한다. 202 응답에는 상태 Endpoint의 URI를 포함하여 비동기 메서드의 상태를 모니터링 할 수 있도록 해야 한다.
        
        클라이언트가 이 Endpoint에 GET 요청을 보내는 경우 비동기 메서드 요청의 현재 상태가 반환된다.
        
        필요에 따라 예상 완료 시간 또는 작업을 취소하는 링크를 포함할 수 있다. 비동기 작업이 새 리소스를 만드는 경우 작업이 완료된 후 상태 코드 303(기타 참조)를 반환하고, 새 리소스의 URI를 제공하는 위치 헤더를 포함해야 한다.
        
        ---
        
        ## 데이터 페이지 매김 및 필터링 구현
        
        데이터 검색을 최적화하고 Payload 크기를 줄이려면 API 디자인에서 데이터 페이지 매김 및 쿼리 기반 필터링을 구현하는 것이 좋다. 클라이언트는 필요한 데이터의 하위 집합만 요청할 수 있으므로 성능을 향상시키고 대역폭 사용량을 줄일 수 있다.
        
        - **페이징**
            - 큰 데이터셋을 더 작고 관리하기 쉬운 덩어리로 나눈다. Query String으로 limit와 offset을 사용한다.
            - `GET /orders?limit=25&offset=50`
        - **필터링**
            - 클라이언트가 조건을 적용하여 가져올 데이터를 구체화 할 수 있다.
            - `GET /orders?minCost=100&status=shipped`
        - **정렬**
            - 클라이언트가 sort 매개변수를 사용하여 데이터를 정렬할 수 있다.
            - 클라이언트는 fields 매개 변수를 사용하여 필요한 필드만 지정할 수 있다.
            - `/orders?fields=ProductID, Quantity`와 같이 쉼표로 구분된 필드 목록을 허용하는 매개 변수를 사용할 수 있다.
        
        API는 요청된 필드의 유효성을 검사하여 클라이언트가 액세스하도록 허용하고 API를 통해 일반적으로 사용할 수 없는 필드를 노출하지 않도록 해야 한다.
        
        ## 부분 응답 지원
        
        일부 리소스에는 파일 또는 이미지와 같은 큰 이진 필드가 포함된다. 불안정하고 일시적인 연결로 인한 문제를 극복하고 응답 시간을 개선하려면 큰 이진 리소스의 부분 검색을 지원하는 것이 좋다.
        
        부분 응답을 지원하려면 API가 대규모 리소스에 대한 GET 요청에 Accept-Ranges 헤더(부분 요청을 지원한다는 것을 나타내는 헤더)를 지원해야 한다.
        
        또한 이러한 리소스에 대한 HTTP **HEAD 요청**을 구현하는 것이 좋다. HEAD 요청은 리소스를 설명하는 HTTP 헤더만 빈 메시지 본문과 함께 반환한다는 점을 제외하고 GET 요청과 유사하다. 클라이언트는 부분 GET 요청을 사용하여 리소스를 가져올지 여부를 결정하기 위해 HEAD 요청을 실행할 수 있다.
        
        **요청**
        
        ```json
        HEAD [https://api.contoso.com/products/10?fields=productImage](https://api.contoso.com/products/10?fields=productImage)
        ```
        
        **응답**
        
        ```json
        HTTP/1.1 200 OK
        
        Accept-Ranges: bytes
        Content-Type: image/jpeg
        Content-Length: 4580
        ```
        
        `Content-Legnth`: 리소스의 총 크기
        
        `Accept-Ranges`: 해당 GET 작업이 부분 응답을 지원한다는 것을 나타냄
        
        클라이언트는 이 정보로 더 작은 덩어리로 이미지를 검색할 수 있다.
        
        **부분 요청**
        
        ```json
        GET [https://api.contoso.com/products/10?fields=productImage](https://api.contoso.com/products/10?fields=productImage)
        Range: bytes=0-2499
        ```
        
        Range 헤더로 2500 바이트를 가져오도록 하는 요청을 보냄
        
        **응답**
        
        ```json
        HTTP/1.1 206 Partial Content
        
        Accept-Ranges: bytes
        Content-Type: image/jpeg
        Content-Length: 2500
        Content-Range: bytes 0-2499/4580
        
        [...]
        ```
        
        상태 코드 206을 반환하여 이 응답이 부분적임을 나타냄
        
        ---
        
        ## HATEOAS 구현
        
        **HATEOAS(Hypermedia As The Engine Of Application State)**
        
        REST를 사용하는 주된 이유 중 하나는 URI 스키마에 대한 사전 지식 없이 전체 리소스 집합을 탐색할 수 있기 때문이다. 
        
        HTTP GET 요청은 **응답에 하이퍼링크**를 넣을 수 있다. 이 하이퍼링크는 **방금 보낸 API 요청과 관련된 URI와 설명**을 갖고 있다.
        
        이 원칙을 **HATEOAS**라고 한다.
        
        **일반적인 API 구현의 경우**, 클라이언트 애플리케이션의 각 버튼과 링크에 있는 고정된 URI를 통해 API 요청을 보낸다.
        
        반면, **HATEOAS**는 서버에서 클라이언트의 요청과 관련된 다음 API의 URI를 응답으로 보내고, 이 URI를 통해 다음 API 요청을 보낸다.
        
        **예를 들어**, 사용자가 **"상품 목록"** 버튼을 클릭하여 클라이언트가 서버에 상품의 목록을 가져오는 GET 요청을 보냈다고 하자.
        
        **일반적인 API 구현**의 경우 사용자가 다음으로 클릭할 **"상세 보기"** 버튼에 상품에 상세 내용을 가져오는 GET 요청 API가 구현되어 있다.
        
        **HATEOAS**에서는 사용자가 **"상품 목록"** GET 요청을 보내면, 서버에서 **"상세 보기"** 버튼에 사용될 URI을 클라이언트에 보내준다. 그리고 클라이언트는 사용자가 **"상세 보기"** 버튼을 클릭할 경우 서버에서 보내준 URI로 GET 요청을 보내는 것이다.
        
        이 방식은 서버에서 사용하는 **URI 주소가 변경될 경우 유용**하다.
        
        **일반적인 API 구현**에서는 **클라이언트에서 변경된 URI 주소를 업데이트**해야 사용자가 사용할 수 있지만,
        
        **HATEOAS**에서는 클라이언트 **업데이트 없이 서버에서 보내준 URI를 사용**하면 된다.
        
        또한, **HATEOAS**는 **서버가 상황을 통제**할 수 있다.
        
        만약 상품 목록에서 어떤 상품이 품절이 됐을 경우, 서버에서는 해당 상품의 URI를 응답에 보내지 않는다. 이 경우 클라이언트가 해당 상품의 품절 정보를 알기 위해서 서버에 요청을 보내지 않고도, 해당 상품이 품절되었다는 정보를 알 수 있게 된다.
        
        **예시**
        
        ```json
        {
          "orderID":3,
          "productID":2,
          "quantity":4,
          "orderValue":16.60,
          "links":[
            {
              "rel":"customer",
              "href":"https://api.contoso.com/customers/3",
              "action":"GET",
              "types":["text/xml","application/json"]
            },
            {
              "rel":"customer",
              "href":"https://api.contoso.com/customers/3",
              "action":"PUT",
              "types":["application/x-www-form-urlencoded"]
            },
            {
              "rel":"customer",
              "href":"https://api.contoso.com/customers/3",
              "action":"DELETE",
              "types":[]
            },
            {
              "rel":"self",
              "href":"https://api.contoso.com/orders/3",
              "action":"GET",
              "types":["text/xml","application/json"]
            },
            {
              "rel":"self",
              "href":"https://api.contoso.com/orders/3",
              "action":"PUT",
              "types":["application/x-www-form-urlencoded"]
            },
            {
              "rel":"self",
              "href":"https://api.contoso.com/orders/3",
              "action":"DELETE",
              "types":[]
            }]
        }
        ```
        
        `links` 데이터에 **HATEOAS** 관련 정보들이 들어가게 된다.
        
        ---
        
        ## 버전 관리 구현
        
        웹 API는 정적 상태로 유지되지 않는다. 비즈니스 요구 사항이 변경되면 새 리소스 컬렉션이 추가된다.
        
        새 리소스가 추가되면 리소스 간의 관계가 변경될 수 있으며 리소스의 데이터 구조가 수정될 수 있다.
        
        새 요구 사항 또는 다른 요구 사항을 처리하도록 웹 API를 업데이트 하는 것은 간단하지만, 이러한 변경이 웹 API를 사용하는 클라이언트에 미치는 영향을 고려해야 한다.
        
        웹 API를 디자인하고 구현하는 개발자는 해당 API를 완전히 제어할 수 있지만, 파트너는 그렇지 않다.
        
        새 클라이언트에서 새 기능 및 리소스를 사용할 수 있도록 하면서 기존 클라이언트를 계속 지원하는 것이 중요하다.
        
        ### URI 버전 관리
        
        웹 API를 수정하거나 리소스의 스키마를 변경할 때마다 각 리소스의 URI에 버전 번호를 추가한다.
        
        - Ex) [`https://api.contoso.com/v2/customers/3`](https://api.contoso.com/v2/customers/3) 에서 `/v2`
        
        이 방법은 간단하지만 적절한 Endpoint로 요청을 보내야 하는 문제점이 있다.
        
        또한, 버전이 늘어날 수록 다루기가 어렵고, URI에 버전 번호를 포함해야 하기 때문에 HATEOAS의 구현을 복잡하게 한다.
        
        ### 쿼리 문자열 버전 관리
        
        여러 URI를 제공하는 대신 HTTP 요청에 [`https://api.contoso.com/customers/3?version=2`](https://api.contoso.com/customers/3?version=2) 처럼 쿼리 문자열 내의 매개 변수를 사용하여 리소스의 버전을 지정할 수 있다.
        
        이 방법은 동일한 리소스가 항상 동일한 URI에서 검색된다는 의미 체계에 이점이 있다. 그러나 서버가 URI의 `?version=2` 같은 부분을 직접 해석하고 그에 맞는 버전을 골라 응답해주는 추가적인 작업이 필요하다.
        
        또한, URI 버전 관리와 마찬가지로 HATEOAS의 구현을 복잡하게 한다.
        
        ### 헤더 버전 관리
        
        버전 번호를 쿼리 문자열 매개 변수로 추가하지 않고 리소스의 버전을 나타내는 사용자 지정 헤더를 구현할 수 있다.
        
        이 방법을 사용하려면 클라이언트가 모든 요청에 적절한 헤더를 추가해야 한다.
        
        HATEOAS를 구현하려면 모든 링크에 적절한 사용자 지정 헤더를 포함해야 한다.
        
        ### 미디어 유형 버전 관리
        
        클라이언트가 서버에 HTTP GET 요청을 보낼 때 `Accept` 헤더를 사용하여 처리할 수 있는 콘텐츠의 형식을 지정해야 한다
        
         일반적으로 `Accept` 헤더의 목적은 클라이언트가 응답 본문이 XML/JSON 또는 클라이언트가 분석할 수 있는 다른 일반적인 형식인지 여부를 지정하도록 허용하는 것이다. 이 Accept 헤더에 리소스의 버전을 알 수 있는 정보를 포함할 수 있다.
        
        **예시**
        
        ```json
        GET [https://api.contoso.com/customers/3](https://api.contoso.com/customers/3)
        Accept: application/vnd.contoso.v1+json
        ```
        
        ---
        
        ## API에서 분산 추적 기능 및 추적 컨텍스트 기능 사용 설정
        
        **분산 시스템**과 **MSA(Micro Service Architecture)**가 표준이 됨에 따라 최신 아키텍처의 복잡성이 증가한다.
        
        API 요청에서 추적 컨텍스트를 전파하는 등의 `Correlation-IDX-Request-IDX-Trace-ID` 헤더를 사용하는 것이 End To End 가시성을 높이는데 좋다.
        
        이 방법을 사용하면 클라이언트에서 백엔드 서비스로 이동하는 요청을 추적할 수 있다.
        
        오류를 신속하게 식별하고, 대기 시간을 모니터링하고, 서비스 간에 API 종속성을 매핑할 수 있다.
        
        ### 추적 컨텍스트
        
        API가 어떤 서비스를 경유했는지 확인하기 위해 고유 ID를 발급하고, 호출한 서비스에 고유 ID를 전파하여 각 서비스에 로그를 기록하는 방법
        
        이동 경로를 추적할 수 있기 때문에 어떤 서비스에서 오류가 발생했는지 확인하기 쉽다.
        
        ---
        
        ## Web API 완성도 모델
        
        2008년, 레너드 리처드슨은 웹 API용 리처드슨 성숙 모델(RMM)을 제안했다.
        
        RMM은 웹 API에 대한 4가지 완성도 수준을 정의하며, 웹 서비스 설계에 대한 아키텍처 접근 방식인 REST 원칙을 기반으로 한다.
        
        - **수준 0**: 하나의 URI를 정의하고 모든 작업은 이 URI에 대한 POST 요청이다. 단순 개체 액세스 프로토콜 웹 서비스가 일반적으로 이 수준이다.
        - **수준 1**: 개별 리소스에 대한 별도의 URI를 만든다. 아직 RESTful이 아니지만 RESTful 디자인에 맞게 조정되기 시작하는 수준이다.
        - **수준 2**: HTTP 메서드를 사용하여 리소스에 대한 작업을 정의한다. 실제로 게시된 많은 웹 API의 수준이다.
        - **수준 3**: HATEOAS를 사용한다. 이 수준이 실제 RESTful한 API다.
        
        ---
        
        ## OpenAPI Initiative(주도권)
        
        **OpenAPI Initiative**는 공급업체 전체에서 REST API 설명을 표준화하기 위해 업계 컨소시엄에 의해 만들어졌다.
        
        표준화 사양은 OpenAPI Initiative에 포함되고 OAS(Open API 사양)로, 이름이 바뀌기전에는 Swagger라고 불렀다.
        
        ### RESTful 웹 API에 OpenAPI를 채택하기 위한 사항
        
        - OAS에는 REST API 디자인에 대한 의견 지침 집합이 함께 제공된다. 이 지침은 상호 운용성에 유리하지만 디자인이 사양을 준수하는지 확인해야 한다.
        - OpenAPI는 구현 우선 접근 방식 대신 계약 우선 접근 방식을 사용한다. 계약 우선은 먼저 API 계약을 디자인한 다음, 계약을 구현하는 코드를 작성하는 것을 의미한다.
        - Swagger(OpenAPI)와 같은 도구는 API 계약에서 클라이언트 라이브러리 또는 설명서를 생성할 수 있다.

정리된 글을 바탕으로 블로그를 작성하여 주세요